---
title: 创建自定义 Python 组件
slug: /components-custom-components
---

自定义组件通过继承自 `Component` 的 Python 类扩展 Langflow 的功能。这使得可以集成新功能、数据操作、外部服务和专业工具。

在 Langflow 基于节点的环境中，每个节点都是执行离散功能的"组件"。自定义组件是定义以下内容的 Python 类：

* **输入** — 您的组件需要的数据或参数。
* **输出** — 您的组件向下游节点提供的数据。
* **逻辑** — 您如何处理输入以产生输出。

创建自定义组件的好处包括无限的可扩展性、可重用性、基于输入的自动 UI 字段生成以及节点之间的类型安全连接。

创建自定义组件用于执行专门任务、调用 API 或添加高级逻辑。

Langflow 中的自定义组件基于：

* 继承自 `Component` 的 Python 类。
* 标识和描述组件的类级属性。
* 确定数据流的输入和输出列表。
* 用于日志记录和高级逻辑的内部变量。

## 类级属性

定义这些属性来控制自定义组件的外观和行为：

```python
class MyCsvReader(Component):
    display_name = "CSV Reader"      # 在节点标题中显示
    description = "Reads CSV files"  # 工具提示文本
    icon = "file-text"              # 视觉标识符
    name = "CSVReader"              # 唯一内部 ID
    documentation = "http://docs.example.com/csv_reader"  # 可选
```

* **display_name**: 节点标题中的用户友好标签。
* **description**: 工具提示中显示的简要摘要。
* **icon**: 来自 Langflow 图标库的视觉标识符。
* **name**: 唯一的内部标识符。
* **documentation**: 外部文档的可选链接。

:::tip 图标使用
Langflow 使用 [Lucide](https://lucide.dev/icons) 图标。要为您的组件分配图标，请将图标属性设置为 Lucide 图标的名称作为字符串，例如 `icon = "file-text"`。Langflow 会自动从 Lucide 库渲染图标。
:::

### 自定义组件的结构

**Langflow 自定义组件**不仅仅是一个具有输入和输出的简单类。它包括一个内部结构，具有可选的生命周期步骤、输出生成、前端交互和逻辑组织。

基本组件：

* 继承自 `langflow.custom.Component`。
* 声明元数据，如 `display_name`、`description`、`icon` 等。
* 定义 `inputs` 和 `outputs` 列表。
* 实现与输出规范匹配的方法。

最小的自定义组件骨架包含以下内容：

```python
from langflow.custom import Component
from langflow.template import Output

class MyComponent(Component):
    display_name = "My Component"
    description = "A short summary."
    icon = "sparkles"
    name = "MyComponent"

    inputs = []
    outputs = []

    def some_output_method(self):
        return ...
```
### 内部生命周期和执行流程

Langflow 的引擎管理：

* **实例化**：创建组件并初始化内部结构。
* **分配输入**：来自 UI 或连接的值被分配给组件字段。
* **验证和设置**：可选钩子如 `_pre_run_setup`。
* **输出生成**：`run()` 或 `build_results()` 触发输出方法。

**可选钩子**：

* `initialize_data` 或 `_pre_run_setup` 可以在组件主要执行前运行设置逻辑。
* `__call__`、`run()` 或 `_run()` 可以被重写以自定义组件的调用方式或定义自定义执行逻辑。

### 输入和输出

自定义组件输入使用以下属性定义：

* `name`、`display_name`
* 可选：`info`、`value`、`advanced`、`is_list`、`tool_mode`、`real_time_refresh`

例如：

* `StrInput`：简单文本输入。
* `DropdownInput`：可选择选项。
* `HandleInput`：专门连接。

自定义组件 `Output` 属性定义：

* `name`、`display_name`、`method`
* 可选：`info`

有关更多信息，请参阅[自定义组件输入和输出](/components-custom-components#custom-component-inputs-and-outputs)。

### 关联方法

每个输出都链接到一个方法：

* 输出方法名必须与方法名匹配。
* 该方法通常返回 Message、Data 或 DataFrame 等对象。
* 该方法可以使用 `self.<input_name>` 访问输入。

例如：

```python
Output(
    display_name="File Contents",
    name="file_contents",
    method="read_file"
)
#...
def read_file(self) -> Data:
    path = self.filename
    with open(path, "r") as f:
        content = f.read()
    self.status = f"Read {len(content)} chars from {path}"
    return Data(data={"content": content})
```

### 具有多个输出的组件

组件可以定义多个输出。
每个输出可以有不同的对应方法。
例如：

```python
outputs = [
    Output(display_name="Processed Data", name="processed_data", method="process_data"),
    Output(display_name="Debug Info", name="debug_info", method="provide_debug_info"),
]
```

#### Output Grouping Behavior with `group_outputs`

By default, components in Langflow that define multiple outputs will display them as a dropdown in the UI. This behavior is controlled by the `group_outputs` parameter.

- `group_outputs=False` (default):  
  When a component has more than one output and `group_outputs` is not specified (or set to `False`), the outputs are grouped into a dropdown. The user can choose only one output at a time from the UI.

- `group_outputs=True`:  
  All outputs will be shown simultaneously in the UI. This is useful when the component is expected to return multiple values that should be used in parallel downstream.

#### Example: 

1. `group_outputs=False` (default behavior)

```python
outputs = [
    Output(
        name="structured_output",
        display_name="Structured Output",
        method="build_structured_output",
    ),
    Output(
        name="dataframe_output",
        display_name="DataFrame Output",
        method="build_structured_dataframe",
    ),
]
```

In this example, both outputs will be available via a dropdown selection in the UI.

Note: Since `group_outputs=False` is the default behavior, it does not need to be explicitly set in the component.

2. `group_outputs=True`

```python
outputs = [
    Output(
        name="true_result",
        display_name="True",
        method="true_response",
        group_outputs=True,
    ),
    Output(
        name="false_result",
        display_name="False",
        method="false_response",
        group_outputs=True,
    ),
]
```

Here, both outputs will appear independently and be selectable directly in the UI.

#### When to Use

- Use `group_outputs=False` when the component is expected to return only one of the outputs depending on the flow logic.

- Use `group_outputs=True` when the component should expose multiple outputs simultaneously, such as structured data and a table that are meant to be used in parallel.

### Common internal patterns

#### `_pre_run_setup()`

To initialize a custom component with counters set:

```python
def _pre_run_setup(self):
    if not hasattr(self, "_initialized"):
        self._initialized = True
        self.iteration = 0
```

#### Override `run` or `_run`
You can override `async def _run(self): ...` to define custom execution logic, although the default behavior from the base class usually covers most cases.

#### Store data in `self.ctx`
Use `self.ctx` as a shared storage for data or counters across the component's execution flow:

```python
def some_method(self):
    count = self.ctx.get("my_count", 0)
    self.ctx["my_count"] = count + 1
```

## 目录结构要求

默认情况下，Langflow 在 `langflow/components` 目录中查找自定义组件。

如果您使用 [LANGFLOW_COMPONENTS_PATH](/environment-variables#LANGFLOW_COMPONENTS_PATH) 环境变量在不同位置创建自定义组件，则组件必须按特定目录结构组织，以便正确加载并在 UI 中显示：

```
/your/custom/components/path/    # Base directory set by LANGFLOW_COMPONENTS_PATH
    └── category_name/          # Required category subfolder that determines menu name
        └── custom_component.py # Component file
```

组件必须放置在**类别文件夹**内，而不是直接放在基础目录中。
类别文件夹名称决定组件在 Langflow **组件**菜单中的显示位置。

例如，要将组件添加到 **Helpers** 类别，请将其放在 `helpers` 子文件夹中：

```
/app/custom_components/          # LANGFLOW_COMPONENTS_PATH
    └── helpers/                 # Displayed within the "Helpers" category
        └── custom_component.py  # Your component
```

You can have multiple category folders to organize components into different categories:
```
/app/custom_components/
    ├── helpers/
    │   └── helper_component.py
    └── tools/
        └── tool_component.py
```

This folder structure is required for Langflow to properly discover and load your custom components. Components placed directly in the base directory will not be loaded.

```
/app/custom_components/          # LANGFLOW_COMPONENTS_PATH
    └── custom_component.py      # Won't be loaded - missing category folder!
```

## 自定义组件输入和输出

输入和输出定义了数据如何通过组件流动、如何在 UI 中显示以及如何验证与其他组件的连接。

### 输入

输入在类级别的 `inputs` 列表中定义。当 Langflow 加载组件时，它使用此列表在 UI 中渲染组件字段和[端口](/concepts-components#component-ports)。用户或其他组件提供值或连接来填充这些输入。

输入通常是来自 `langflow.io` 的类的实例（如 `StrInput`、`DataInput` 或 `MessageTextInput`）。最常见的构造函数参数是：

* **`name`**: 内部变量名，通过 `self.<name>` 访问。
* **`display_name`**: 在 UI 中向用户显示的标签。
* **`info`** *(可选)*: 工具提示或简短描述。
* **`value`** *(可选)*: 默认值。
* **`advanced`** *(可选)*: 如果为 `True`，将字段移动到"高级"部分。
* **`required`** *(可选)*: 如果为 `True`，强制用户提供值。
* **`is_list`** *(可选)*: 如果为 `True`，允许多个值。
* **`input_types`** *(可选)*: 限制允许的连接类型（例如，`["Data"]`、`["LanguageModel"]`）。

以下是最常用的输入类及其典型用法。

**文本输入**：用于简单文本条目。
* **`StrInput`** 创建单行文本字段。
* **`MultilineInput`** 创建多行文本区域。

**数字和布尔输入**：确保用户只能输入有效的数字或布尔数据。
* **`BoolInput`**、**`IntInput`** 和 **`FloatInput`** 为布尔、整数和浮点值提供字段，确保类型一致性。

**下拉菜单**：用于从预定义选项中选择，对模式或级别很有用。
* **`DropdownInput`**

**密钥**：敏感数据的专用输入，确保在 UI 中隐藏输入。
* **`SecretStrInput`** 用于 API 密钥和密码。

**专门数据输入**：确保 UI 中的类型检查和颜色编码连接。
* **`DataInput`** 期望 `Data` 对象（通常具有 `.data` 和可选的 `.text`）。
* **`MessageInput`** 期望 `Message` 对象，用于聊天或基于代理的流程。
* **`MessageTextInput`** 简化对 `Message` 的 `.text` 字段的访问。

**基于句柄的输入**：用于连接特定类型的输出，确保正确的管道连接。
- **`HandleInput`**

**文件上传**：允许用户直接通过 UI 上传文件或从其他组件接收文件路径。
- **`FileInput`**

**列表**：设置 `is_list=True` 以接受多个值，非常适合批处理或分组操作。

This example defines three inputs: a text field (`StrInput`), a boolean toggle (`BoolInput`), and a dropdown selection (`DropdownInput`).

```python
from langflow.io import StrInput, BoolInput, DropdownInput

inputs = [
    StrInput(name="title", display_name="Title"),
    BoolInput(name="enabled", display_name="Enabled", value=True),
    DropdownInput(name="mode", display_name="Mode", options=["Fast", "Safe", "Experimental"], value="Safe")
]
```

### 输出

输出在类级别的 `outputs` 列表中定义。当 Langflow 渲染组件时，每个输出都成为 UI 中的连接点。当您将某些内容连接到输出时，Langflow 会自动调用相应的方法并将返回的对象传递给下一个组件。

输出通常是来自 `langflow.io` 的 `Output` 实例，具有常见参数：

* **`name`**: 内部变量名。
* **`display_name`**: 在 UI 中显示的标签。
* **`method`**: 调用以产生输出的方法名称。
* **`info`** *(可选)*: 悬停时显示的帮助文本。

该方法必须存在于类中，并建议为其返回类型添加注释以进行更好的类型检查。
您还可以在方法内部设置 `self.status` 消息以显示进度或日志。

**常见返回类型**：
- **`Message`**: 结构化聊天消息。
- **`Data`**: 具有 `.data` 和可选 `.text` 的灵活对象。
- **`DataFrame`**: 基于 Pandas 的表格（`langflow.schema.DataFrame`）。
- **原始类型**: `str`、`int`、`bool`（如果需要类型/颜色一致性，不建议使用）。

在此示例中，`DataToDataFrame` 组件使用输出列表定义其输出。`df_out` 输出链接到 `build_df` 方法，因此当在 UI 中连接时，Langflow 调用此方法并将其返回的 DataFrame 传递给下一个节点。这演示了每个输出如何映射到生成实际输出数据的方法。

```python
from langflow.custom import Component
from langflow.io import DataInput, Output
from langflow.schema import Data, DataFrame

class DataToDataFrame(Component):
    display_name = "Data to DataFrame"
    description = "Convert multiple Data objects into a DataFrame"
    icon = "table"
    name = "DataToDataFrame"

    inputs = [
        DataInput(
            name="items",
            display_name="Data Items",
            info="List of Data objects to convert",
            is_list=True
        )
    ]

    outputs = [
        Output(
            name="df_out",
            display_name="DataFrame Output",
            method="build_df"
        )
    ]

    def build_df(self) -> DataFrame:
        rows = []
        for item in self.items:
            row_dict = item.data.copy() if item.data else {}
            row_dict["text"] = item.get_text() or ""
            rows.append(row_dict)

        df = DataFrame(rows)
        self.status = f"Built DataFrame with {len(rows)} rows."
        return df
```


### 工具模式

您可以通过设置参数 `tool_mode=True` 将自定义组件配置为作为**工具**工作。这使得组件可以在 Langflow 的工具模式工作流中使用，例如被 Agent 组件使用。

Langflow 目前支持以下工具模式输入类型：

* `DataInput`
* `DataFrameInput`
* `PromptInput`
* `MessageTextInput`
* `MultilineInput`
* `DropdownInput`

```python
inputs = [
    MessageTextInput(
        name="message",
        display_name="Mensage",
        info="Enter the message that will be processed directly by the tool",
        tool_mode=True,
    ),
]
```

## 类型注释

在 Langflow 中，**类型注释**允许 Langflow 在视觉上指导用户并保持流程一致性。

类型注释提供：

* **颜色编码**：像 `-> Data` 或 `-> Message` 这样的输出具有不同的颜色。
* **验证**：Langflow 自动阻止不兼容的连接。
* **可读性**：开发人员可以快速理解数据流。
* **开发工具**：在代码编辑器中提供更好的代码建议和错误检查。

### 常见返回类型

**`Message`**

用于聊天风格的输出。

```python
def produce_message(self) -> Message:
    return Message(text="Hello! from typed method!", sender="System")
```
在 UI 中，仅连接到与 Message 兼容的输入。

**`Data`**

用于字典或部分文本等结构化数据。
```python
def get_processed_data(self) -> Data:
    processed = {"key1": "value1", "key2": 123}
    return Data(data=processed)
```

在 UI 中，仅与 DataInput 连接。

**`DataFrame`**

用于表格数据

```python
def build_df(self) -> DataFrame:
    pdf = pd.DataFrame({"A": [1, 2], "B": [3, 4]})
    return DataFrame(pdf)

```

在 UI 中，仅连接到 DataFrameInput。

**原始类型（`str`、`int`、`bool`）**

允许返回原始类型，但建议包装在 Data 或 Message 中以获得更好的 UI 一致性。

```python
def compute_sum(self) -> int:
    return sum(self.numbers)
```

### 类型注释提示

使用类型注释时，请考虑以下最佳实践：

* **始终注释输出**：指定返回类型，如 `-> Data`、`-> Message` 或 `-> DataFrame`，以启用适当的 UI 颜色编码和验证。
* **包装原始数据**：使用 `Data`、`Message` 或 `DataFrame` 包装器，而不是返回普通结构。
* **谨慎使用原始类型**：直接的 `str` 或 `int` 返回对于简单流程来说是可以的，但包装可以提高灵活性。
* **也要注释辅助函数**：即使是内部的，类型化也能提高可维护性和清晰度。
* **处理边缘情况**：在需要时，优先返回带有错误字段的结构化 `Data`。
* **保持一致性**：在组件中使用相同的类型，使流程可预测且更易于构建。


## Enable dynamic fields

In **Langflow**, dynamic fields allow inputs to change or appear based on user interactions. You can make an input dynamic by setting `dynamic=True`.
Optionally, setting `real_time_refresh=True` triggers the `update_build_config` method to adjust the input's visibility or properties in real time, creating a contextual UI that only displays relevant fields based on the user's choices.

In this example, the operator field triggers updates via `real_time_refresh=True`.
The `regex_pattern` field is initially hidden and controlled via `dynamic=True`.

```python
from langflow.io import DropdownInput, StrInput

class RegexRouter(Component):
    display_name = "Regex Router"
    description = "Demonstrates dynamic fields for regex input."

    inputs = [
        DropdownInput(
            name="operator",
            display_name="Operator",
            options=["equals", "contains", "regex"],
            value="equals",
            real_time_refresh=True,
        ),
        StrInput(
            name="regex_pattern",
            display_name="Regex Pattern",
            info="Used if operator='regex'",
            dynamic=True,
            show=False,
        ),
    ]
```

### Implement `update_build_config`

When a field with `real_time_refresh=True` is modified, Langflow calls the `update_build_config` method, passing the updated field name, value, and the component's configuration to dynamically adjust the visibility or properties of other fields based on user input.

This example will show or hide the `regex_pattern` field when the user selects a different operator.

```python
def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:
    if field_name == "operator":
        if field_value == "regex":
            build_config["regex_pattern"]["show"] = True
        else:
            build_config["regex_pattern"]["show"] = False
    return build_config
```

### Additional Dynamic Field Controls

You can also modify other properties within `update_build_config`, such as:
* `required`: Set `build_config["some_field"]["required"] = True/False`

* `advanced`: Set `build_config["some_field"]["advanced"] = True`

* `options`: Modify dynamic dropdown options.

### Tips for Managing Dynamic Fields

When working with dynamic fields, consider the following best practices to ensure a smooth user experience:

* **Minimize field changes**: Hide only fields that are truly irrelevant to avoid confusing users.
* **Test behavior**: Ensure that adding or removing fields doesn't accidentally erase user input.
* **Preserve data**: Use `build_config["some_field"]["show"] = False` to hide fields without losing their values.
* **Clarify logic**: Add `info` notes to explain why fields appear or disappear based on conditions.
* **Keep it manageable**: If the dynamic logic becomes too complex, consider breaking it into smaller components, unless it serves a clear purpose in a single node.


## 错误处理和日志记录

在 Langflow 中，强大的错误处理确保您的组件行为可预测，即使在发生意外情况时，如无效输入、外部 API 失败或内部逻辑错误。

### 错误处理技术

* **抛出异常**：
  如果发生严重错误，您可以抛出标准 Python 异常，如 `ValueError`，或专门的异常，如 `ToolException`。Langflow 将自动捕获这些异常并在 UI 中显示适当的错误消息，帮助用户快速识别出了什么问题。
  ```python
  def compute_result(self) -> str:
      if not self.user_input:
          raise ValueError("No input provided.")
      # ...
  ```
* **返回结构化错误数据**：
  与突然停止流程不同，您可以返回包含"error"字段的 Data 对象。这种方法允许流程继续运行，并使下游组件能够检测和优雅地处理错误。
  ```python
  def run_model(self) -> Data:
    try:
        # ...
    except Exception as e:
        return Data(data={"error": str(e)})
  ```

### 改进调试和流程管理

* **使用 `self.status`**：
  每个组件都有一个状态字段，您可以在其中存储关于执行结果的简短消息——如成功摘要、部分进度或错误通知。这些直接显示在 UI 中，使用户更容易进行故障排除。
  ```python
  def parse_data(self) -> Data:
  # ...
  self.status = f"Parsed {len(rows)} rows successfully."
  return Data(data={"rows": rows})
  ```
* **使用 `self.stop(...)` 停止特定输出**：
  当某些条件失败时，您可以停止个别输出路径，而不影响整个组件。这在处理具有多个输出分支的组件时特别有用。
  ```python
  def some_output(self) -> Data:
  if <some condition>:
      self.stop("some_output")  # 告诉 Langflow 没有数据流动
      return Data(data={"error": "Condition not met"})
  ```

* **记录事件**：
  您可以在组件内部记录关键执行详细信息。日志显示在组件详细视图的"日志"或"事件"部分，可以稍后通过流程的调试面板或导出文件访问，为更容易的调试提供组件行为的清晰跟踪。
  ```python
  def process_file(self, file_path: str):
  self.log(f"Processing file {file_path}")
  # ...
  ```

### 错误处理和日志记录提示

要构建更可靠的组件，请考虑以下最佳实践：

* **早期验证输入**：在开始时捕获缺失或无效的输入，以防止逻辑错误。
* **使用 `self.status` 进行总结**：使用简短的成功或错误摘要来帮助用户快速理解结果。
* **保持日志简洁**：专注于有意义的消息，避免使 UI 混乱。
* **返回结构化错误**：在适当时，返回 `Data(data={"error": ...})` 而不是抛出异常，以允许下游处理。
* **有选择地停止输出**：只有在必要时才使用 `self.stop(...)` 停止特定输出，以保持其他地方的正确流程行为。

## 向 Langflow 贡献自定义组件

请参阅[如何贡献](/contributing-components)来向 Langflow 贡献您的自定义组件。

